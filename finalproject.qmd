---
title: "Final Project"
author: "Jane Finocharo, Adriana Vance, and Ruining Zheng"
execute:
  message: false
  warning: false
format:
  html:
    embed-resources: true
    code-fold: true
date: today
editor: visual
bibliography: references.bib
---

## Introduction

In 2021, approximately 10% of American households experienced food insecurity - a lack of access to enough food for a healthy, active life - at some point during the year [@rabbitt]. The percentage of people experiencing food security varies significantly between counties, ranging from 2% to 26% [@hake2023]. Understanding the key predictors of food insecurity at the county level could help us target interventions and resources where they're needed most and identify policies that are effective at reducing or preventing food insecurity.

## Data Sources

For these analyses, we compiled data from three different sources to identify the factors predicting rates of food insecurity at the county level in the United States:

-   **County Health Rankings.** The County Health Rankings provide annual data for hundreds of health-related indicators at the county level. This includes a measure of the proportion of people in each county experiencing food insecurity. For our outcome variable, we pulled this measure of food insecurity from the most recent data release (County Health Rankings 2024). We pulled data from the previous data release (County Health Rankings 2023) for predictor variables in our model. These variables include sociodemographic and economic measures like race/ethnicity, income inequality, high school graduation rates, unemployment, and cost burden of housing and healthcare; percent living in a rural area; and other environmental and health factors like air pollution, traffic volume, and access to exercise opportunities.
-   **USDA Food Atlas**. \*\* REMOVED VARS THAT HAD MISSING VALUES FOR MULTIPLE YEARS IN A ROW, RAN NA OMIT FOR THE REST
-   **SNAP Policy Datasets.**

## Set Up

### Load Libraries

```{r}
library(tidyverse)
library(here)
library(readxl)
library(tidyr)
library(lubridate)
library(DescTools)
library(tidymodels)
library(gridExtra)
library(vip)
library(glmnet)
library(patchwork)

```

### Loading, Cleaning and Merging Datasets

First, create a folder in your directory called "data". Then follow the instructions below to access the datasets and save them with the correct names in the data folder:

\- **County Health Rankings 2024**: At [this link](https://www.countyhealthrankings.org/health-data/methodology-and-sources/data-documentation), click "2024 CHR CSV Analytic Data". Rename file "CHR_2024.csv"

\- **County Health Rankings 2023**: At [this link](https://www.countyhealthrankings.org/health-data/methodology-and-sources/data-documentation), click "2023 CHR CSV Analytic Data". Rename file "CHR_2023.csv"

\- **Food Environment Atlas**: At [this link](https://www.ers.usda.gov/data-products/food-environment-atlas/data-access-and-documentation-downloads/#Current%20Version), click "Food Environemnt Atlas .csv Files." Open the .zip file, move "StateAndCountyData.csv" into data folder, rename "FEA.csv". Move "SupplementalDataCounty.csv" into data folder, rename "FEA_supplement.csv". Move "VariableList.csv" into the data folder.

\- **SNAP Policy Data:** At [this link](https://www.ers.usda.gov/data-products/snap-policy-data-sets/), click "Snap Policy Database." Move into data folder, rename "snap.xlsx"

```{r}
                                              
# county health rankings
chr_col_names_2024 <- names(read_csv(here("data", "CHR_2024.csv"), n_max = 0))
chr_2024 <- read_csv(here("data", "CHR_2024.csv"), col_names = chr_col_names_2024, skip = 2)

chr_col_names_2023 <- names(read_csv(here("data", "CHR_2023.csv"), n_max = 0))
chr_2023 <- read_csv(here("data", "CHR_2023.csv"), col_names = chr_col_names_2023, skip = 2)

# food atlas + food atlas supplement
food_atlas <- read_csv(here("data", "FEA.csv"))
food_atlas_supplement <- read_csv(here("data", "FEA_supplement.csv"))
atlas_vars <- read_csv(here("data", "VariableList.csv"))

# SNAP policy data
snap <- read_excel(here("data", "snap.xlsx"), sheet = 2)

```

#### Tidying the Datasets for Merging

##### Food Atlas Dataframe

```{r}

# Changing values from scientific notation, and rounding decimals to be shorter
food_atlas <- food_atlas %>%
  mutate(Value = format(Value, scientific = FALSE)) %>%
  mutate(Value = map_dbl(food_atlas$Value, round, digits = 4))

# Pivoting dataset to tidy - variables as columns and counties as rows 

atlas_test <- food_atlas %>%
  pivot_wider(id_cols  = c(FIPS), # ID col is FIPS because of identical county names
              names_from = c(Variable_Code), 
              values_from = Value) %>%
  filter(FIPS > 1000) 

# There are two more variables than counties. The two observations here have NA values for all variables so will be filtered from the data
atlas_test %>%
  filter(is.na(atlas_test$LACCESS_POP10))

#Filtering here
atlas_test <- atlas_test %>%
  filter(FIPS != 2158 & FIPS != 46102)

# Create a tibble with unique state-county FIPS combos 
strings <- c("County", "Total", "Parish", "city", "Borough", "Census Area", "Municipality")
fips_distinct <- food_atlas %>%
  group_by(FIPS) %>%
  select(State, County, FIPS) %>%
  distinct() %>%
  filter(!str_detect(County, pattern = paste(strings, collapse = "|")))

# Bind dataframes with data and county/state names

food_atlas <- full_join(fips_distinct, atlas_test)

```

Here, we pivoted the data to be wider such that each unique county name formed a row. To do so, we used the FIPS codes which are unique identifiers of each county. After pivoting, we noticed there were state-level variables and duplicates of each county. We filtered out any county duplicates using stringr, and created a dataframe of unique state, county, and FIPS codes to join with the final dataset. The final dataset has 3,143 unique observations, which is the number of counties in the U.S.

##### SNAP Dataframe

```{r}

# Round the decimals to be the same pattern as above
snap <- snap %>%
  mutate_if(is.numeric, ~ round(., digits = 4)) %>%
  filter(yearmonth >= 201001) %>% # Only keep the data after year 2010. to assure that our analysis is closely connected to the current policies and circumstances.
  mutate(yearmonth = ym(yearmonth)) %>%
  mutate(year = year(yearmonth)) # Since the CHR data only contains year data, we also mutate a new column for year in SNAP. 

snap_natest <- snap %>%
  select(-transben, -call_any, -faceini, -facerec, -(starts_with("cert"))) %>% # Removes variables with NA values for multiple years
  na.omit() # Removes any NA observations left, mostly in 2020 due to pandemic 

# Function to change year-month observations into year observations, taking the most common value 
#' Year-Month -> Year
#'
#' @param date # This is actually for the year of the dataset. Used to filter dataset from years 2010-2020
#' @param yearname # This is also the year, but must be written in quotes. Ex: yearname = "2016" 
#'
#' @return # Returns a dataframe of a specific year of the SNAP data. Each observation is the mode of year-month observations in the original data. 
#' @export
#'
#' @examples
#' snap_2010 <- rename_columns(date = 2010, yearname = "_2010")

rename_columns <- function(date, yearname){
  snap_date <- snap_natest %>%
    filter(year == date) %>%
    group_by(state_pc, year) %>%
    summarize_all(list(mode = ~Mode(.))) %>%
    select(-state_fips_mode, -statename_mode, -yearmonth_mode) %>%
    distinct(state_pc, .keep_all = TRUE)  # Keep only one row per state_pc

  names_date <- names(snap_date)
  new_date <- paste(names_date, yearname, sep = "")
  names(snap_date) <- new_date

  return(snap_date)
}
snap_2010 <- rename_columns(date = 2010, yearname = "_2010")
snap_2011 <- rename_columns(date = 2011, yearname = "_2011")
snap_2012 <- rename_columns(date = 2012, yearname = "_2012")
snap_2013 <- rename_columns(date = 2013, yearname = "_2013")
snap_2014 <- rename_columns(date = 2014, yearname = "_2014")
snap_2015 <- rename_columns(date = 2015, yearname = "_2015")
snap_2016 <- rename_columns(date = 2016, yearname = "_2016")
snap_2017 <- rename_columns(date = 2017, yearname = "_2017")
snap_2018 <- rename_columns(date = 2018, yearname = "_2018")
snap_2019 <- rename_columns(date = 2019, yearname = "_2019")
snap_2020 <- rename_columns(date = 2020, yearname = "_2020")

snap_year <- bind_cols(snap_2010, 
                       snap_2011, 
                       snap_2012, 
                       snap_2013, 
                       snap_2014, 
                       snap_2015, 
                       snap_2016, 
                       snap_2017, 
                       snap_2018, 
                       snap_2019, 
                       snap_2020) %>%
  rename(state = state_pc_2010) %>%
  group_by(state) %>%
  select(-starts_with("state_pc"), 
         -starts_with("year"))

```

The SNAP dataframe is a state-level dataframe of monthly reported data of SNAP policy relevant information by each state from 1996 to 2019. It supposed to have 51*12*10 = 6120 observations, but since we filter out data before year 2010 as well as states' data with too many missing values, the actual observation number is smaller.

Through looking at the documentation for the SNAP policy data, we learned that some variables were systematically missing. There were a few variables (transben, call_any, faceini, facerec, and the recertification variables) that had missing data for multiple years. Because the variables were missing not at random, we decided to remove them from our analysis. The rest of the variables were missing data from 2020, which is likely due to lack of data collection during the pandemic. NA observations were removed because imputation would likely not be able to reflect policy changes made during the pandemic.

After dealing with the missing values, we grouped the dataset by year and state, and took the mode of each observation. The data was categorical, so mode was used to capture the most frequent instance of each policy during each year.

##### County Health Rankings

```{r}

# selecting and renaming key variables. adding _chr at end so we know which variables came from CHR in merged dataset

chr_2023_small <- 
  chr_2023 |> 
  select(state_fips = 'State FIPS Code',
         county_fips = 'County FIPS Code',
         state = 'State Abbreviation',
         fips_5_digit = '5-digit FIPS Code',
         county = 'Name',
         food_env_index_chr = 'Food Environment Index raw value', # 2019
         exercise_access_chr = 'Access to Exercise Opportunities raw value', #2023, 2020, 2022
         child_poverty_chr = 'Children in Poverty raw value',
         income_inequality_chr = 'Income Inequality raw value',
         air_pollution_chr = 'Air Pollution - Particulate Matter raw value',
         limited_healthy_food_chr = 'Limited Access to Healthy Foods raw value',
         uninsured_adults_chr = 'Uninsured Adults raw value',
         uninsured_children_chr = 'Uninsured Children raw value',
         childcare_cost_burden_chr = 'Child Care Cost Burden raw value',
         traffic_volume_chr = 'Traffic Volume raw value',
         rural_chr = '% Rural raw value', 
         hs_grad_rate_chr = 'High School Graduation raw value',
         life_expectancy_chr = 'Life Expectancy raw value',
         pct_under18_chr = '% Below 18 Years of Age raw value',
         housing_cost_burden_chr = 'Severe Housing Cost Burden raw value',
         residential_segregation_chr = 'Residential Segregation - Black/White raw value',
         pct_NH_Black_chr = '% Non-Hispanic Black raw value',
         pct_Hispanic_chr = '% Hispanic raw value',
         pct_NH_white_chr = '% Non-Hispanic White raw value',
         pct_not_english_prof_chr = '% Not Proficient in English raw value',
         unemployment_chr = 'Unemployment raw value') |> 
  filter(county_fips!="000") |> 
  mutate(
    fips = as.numeric(fips_5_digit)) |> 
  select(!c(state_fips, county_fips, fips_5_digit)) |> 
  mutate_if(is.numeric, ~ round(., digits = 4))



chr_2024_small <- 
  chr_2024 |> 
  select(state_fips = 'State FIPS Code',
         county_fips = 'County FIPS Code',
         state = 'State Abbreviation',
         fips_5_digit = '5-digit FIPS Code',
         county = 'Name',
         food_insecurity_chr = 'Food Insecurity raw value') |> 
  filter(county_fips!="000") |> 
  mutate(
    fips = as.numeric(fips_5_digit)) |> 
  select(!c(state_fips, county_fips, fips_5_digit)) |> 
  mutate_if(is.numeric, ~ round(., digits = 4))

anti_join(chr_2024_small, chr_2023_small, by = "fips")
anti_join(chr_2023_small, chr_2024_small, by = "fips")


chr_2024_small <- 
  chr_2024_small |> 
  filter(fips !=2063,
         fips !=  2066)
chr_2023_small <- 
  chr_2023_small |> 
  filter(fips != 2261)


anti_join(chr_2024_small, chr_2023_small, by = "fips")
anti_join(chr_2023_small, chr_2024_small, by = "fips")

chr_small <- 
  full_join(chr_2024_small, chr_2023_small, by = "fips")

glimpse(chr_small)

```

#### Merging Data

```{r}

# merging atlas and CHR
food_atlas <- food_atlas %>%
  rename(fips = FIPS)

anti_join(food_atlas, chr_small, by = "fips")
anti_join(chr_small, food_atlas)

```

The anti joins above show the counties in each dataset that are not represented in the other. All of these counties were either changed or deleted in the time that these data were collected. In order to be able to merge our datasets, we will remove these counties from the data.

```{r}

food_atlas <- food_atlas %>%
  filter(fips != 2261, 
         fips != 2270, 
         fips != 46113, 
         fips != 51515)
chr_small <- chr_small %>%
  filter(fips != 2158, 
         fips != 46102)

# Checking that there are no other unmatched observations 
anti_join(food_atlas, chr_small, by = "fips") # success!
anti_join(chr_small, food_atlas, by = "fips") # success!

atlas_chr <- full_join(food_atlas, chr_small, by = "fips") 

snap_year <- snap_year %>%
  rename(State = state)

atlas_chr_snap <- left_join(atlas_chr, snap_year)

# We also would like to filter out variables that directly indicate food security/insecurity value in other data frames besides the CHR data.
atlas_chr_snap <- atlas_chr_snap %>%
  select(-contains(c("FOODSEC", "FOODINSEC")))

```

### Predictive Model

#### Problem Formulation

Our final dataset contains information about county and state-level characteristics that our research has shown may have an impact on food insecurity. We aim to create a model that can use these past characteristics to predict food insecurity levels in the future. As described above, our data spans multiple time periods and covers county characteristics related to both food access and socioeconomic status of counties. 
The characteristics in the data range from years 2010-2023, and will be used to predict the County Health Rankings food insecurity estimates from 2024. 

#### Split Data into Training and Testing Data

By splitting our data into training and testing data, we will be able to see how our predictive model performs on unseen data. In the future, this would ideally be applied to a new data set of all counties with these characteristics, to predict food insecurity levels in proceeding years. 


```{r}
set.seed(20240430)

split <- initial_split(data = atlas_chr_snap, prop = 0.75)

training <- training(split) 
testing <- testing(split)

```

#### Exploratory Data Analysis

Exploratory data analysis will be important in understanding how our models can best perform. Informed by our research, our exploratory data analysis will allow us to further understand the potential relationships between certain variables in our dataset, and food insecurity levels. 
```{r}

training %>%
  ggplot(mapping = aes(x = POVRATE15, y = food_insecurity_chr, color = POVRATE15)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE) +
  labs(title = "Relationship between poverty rate and food insecurity value",
       x = "Poverty rate",
       y = "Food insecurity value") + 
  theme_minimal()

```

The line chart shows a general linear relationship between the poverty rate of each county and the food insecurity value. As the poverty rate increases, the food insecurity value also increases.

We also think the food security is closely connected to the programs and policies participants since the purposes of these benefits are to help people who are in danger of food insecurity due to various reasons. Thus, we selected the program participant proportional variables and observe the density distribution of them and of food security value.

```{r}

# Select all program participants variables
program_participants <- training %>%
  select(
    fips,
    PCT_SNAP17, 
    PCT_NSLP17, 
    PCT_SBP17, 
    PCT_SFSP17, 
    PCT_WIC17, 
    PCT_WICINFANTCHILD16,
    PCT_WICWOMEN16,
    food_insecurity_chr
  )

# Density distribution of food insecurity value among all observations
program_participants %>%
  ggplot() +
  geom_density(mapping = aes(x = food_insecurity_chr), color = "indianred") +
  labs(title = "Density plot for food insecurity score",
       x = "Score") +
  theme_minimal()
```
The density plot for our dependent variable, the food insecurity value, shows a close to normal distributed bell shape. 0.11 is most common score for the counties with a high density, or high relative probability. 

```{r}
# Density distribution of program participant proportions among all observations

p1 <- program_participants %>%
  ggplot() +
  geom_density(mapping = aes(x = PCT_WIC17), color = "purple") +
  labs(title = "2017 WIC",
       x = "Population proportion") +
  theme_minimal()

p2 <- program_participants %>%
  ggplot() +
  geom_density(mapping = aes(x = PCT_WICINFANTCHILD16), color = "orange") +
  labs(title = "2016 WIC infant and children",
       x = "Infant & children proportion") +
  theme_minimal()

p3 <- program_participants %>%
  ggplot() +
  geom_density(mapping = aes(x = PCT_WICWOMEN16), color = "olivedrab") +
  labs(title = "2016 WIC women",
       x = "Women proportion") +
  theme_minimal()
 
p4 <- program_participants %>%
  ggplot() +
  geom_density(mapping = aes(x = PCT_SNAP17), color = "gold") +
  labs(title = "2017 SNAP",
       x = "Population proportion") +
  theme_minimal()

p5 <- program_participants %>%
  ggplot() +
  geom_density(mapping = aes(x = PCT_NSLP17), color = "dodgerblue") +
  labs(title = "2017 National School Lunch",
       x = "Children proportion") +
  theme_minimal()

p6 <- program_participants %>%
  ggplot() +
  geom_density(mapping = aes(x = PCT_SBP17), color = "green") +
  labs(title = "2017 School Breakfast",
       x = "Children proportion") +
  theme_minimal()

grid.arrange(p1, p2, p3, p4, p5, p6, ncol = 3)

```
Comparing to other programs, WIC program has relatively lower proportion of participants. All six density plots are not showing similar distribution patterns. 
- The proportion of WIC participants concentrate around 1.9% to 2.4%; children and infant proportions are higher, around 21% and 33%, while women participant proportions have multiple peaks, around 2%, 2.4%, 2.7% and 2.9%. 
- SNAP participant proportion in most counties is around 8% or 14%.
- The participation children proportions among children for both school lunch and school breakfast programs are much higher than the previous ones. Density of proportions in national school lunch program has three peaks: 50%, 64%, and 71%. The majority of the counties include more than half of their children within the lunch program.
- The participation proportion distribution in breakfast is relatively lower, and only with two peaks: 24% and 35%. 

The density distribution of the program participation proportions do not show the similar trends as we expected before, so we will do the correlation test to determine whether these variables will be included as predictors.

#### Feature Selection

```{r}

correlation <- training %>%
  select(where(is.numeric)) %>%
  cor()

# Only keep variables have correlation with the food insecurity variable. 
correlation_df <- as.data.frame(correlation) %>%
  select(food_insecurity_chr) %>%
  filter(food_insecurity_chr != 0) %>% # filter out those correlations equal 0
  rownames_to_column() %>%
  pivot_wider(
    names_from = rowname,
    values_from = food_insecurity_chr
  )

# Intersect correlation data frame with training data, so only variables show in both data frame will be left. 
selected_variables <- intersect(names(correlation_df), names(training)) 
as.data.frame(selected_variables)

# Filter out variables that are not in intersection results as the last step assigned to
sub_training <- training[selected_variables]

```

By doing this, we narrow down the number of predictors into 362 variables instead of 604 variables in the original training data.

#### Visualizing Correlations 
Here, we are visualizing the relationship between our food insecurity measure, and some of the predictors chosen in our correlation test. Below are scatter plots of these variables, with smoothed lines representing the linear relationship. 

```{r}

c1 <- training %>%
  ggplot(mapping = aes(x = food_insecurity_chr, y = SNAPSPTH17)) + 
  geom_point(alpha = 0.7, color = "#2FA0E2") + 
  geom_smooth(color = "#F8BE5B") +
  labs(title = "2017 SNAP-authorized stores",
       x = "Insecurity value",
       y = "Stores/1,000 pop") +
  theme_minimal()

c2 <- training %>%
  ggplot(mapping = aes(x = food_insecurity_chr, y = PCT_WICWOMEN16)) + 
  geom_point(alpha = 0.7, color = "#2FA0E2") + 
  geom_smooth(color = "#F8BE5B") +
  labs(title = "Percent of Women WIC Participants, 2016",
       x = "Insecurity value",
       y = "Stores/1,000 pop") +
  theme_minimal()

c3 <- training %>%
  ggplot(mapping = aes(x = food_insecurity_chr, y = PCT_REDUCED_LUNCH15)) + 
  geom_point(alpha = 0.7, color = "#2FA0E2") + 
  geom_smooth(color = "#F8BE5B") +
  labs(title = "Students Eligible for Reduced Price Lunch, 2015",
       x = "Insecurity value",
       y = "Population count") +
  theme_minimal()

c5 <- training %>%
  ggplot(mapping = aes(x = food_insecurity_chr, y = SUPERCPTH16)) + 
  geom_point(alpha = 0.7, color = "#2FA0E2") + 
  geom_smooth(color = "#F8BE5B") +
  labs(title = "2016 Supercenters & club stores/1,000 pop",
       x = "Insecurity value",
       y = "Stores/1,000 pop") +
  theme_minimal()

grid.arrange(c1, c2, c3, c5, ncol = 2)

```
These plots show the relationship between select predictor variables and food insecurity in counties. It is evident that the relationships between predictor variables and food insecurity vary widely across the data, indicating that a non-parametric or more advanced regression method may be useful in creating our predictive model. 
To test this assumption, we created both a LASSO regression and a random forest model, using the predictor variables selected with our correlation test. 

#### Setting up Resampling
Because counties vary widely by population, we chose to conduct stratified sampling based on ACS population estimates provided in the food atlas dataset. This stratified sampling method will ensure there is an even distribution of different population levels in our training data. 
```{r}
sub_folds <- vfold_cv(data = sub_training, v = 10, repeats = 10, strata = Population_Estimate_2018)

```

#### Lasso Regression

In designing our LASSO regression model, we filtered out zero or near-zero variance predictors, which are predictors with few unique values such that they are not useful in predicting variance in food insecurity. For the remaining values, we impute the mean for any missingness rather than omitting NA values. This will allow us to use our model to predict food insecurity values across all counties, rather than omitting counties that have NA values in certain observations. Normalizing predictors standardizes the units of predictor variables. Lastly, step_other pools infrequent values in our categorical variables into an "other category"
```{r}

lasso_rec <- recipe(food_insecurity_chr ~ ., data = sub_training) %>%
  add_role(fips, new_role = "id") %>% # Add ID role for county FIPS code
  step_rm(has_role("id")) %>%
  step_nzv(all_predictors()) %>% # Filter out near zero variance predictors
  step_impute_mean(all_predictors()) %>% # Impute mean for missing values
  step_normalize(all_numeric_predictors()) %>% # Normalize predictors
  step_other(all_nominal(), threshold = 0.05) # Pool infrequent values into "other" category
  
lasso_mod <- linear_reg(penalty = tune(), mixture = 1) %>%
  set_mode(mode = "regression") %>%
  set_engine(engine = "glmnet")
  
lasso_wf <- workflow() %>%
  add_recipe(recipe = lasso_rec) %>%
  add_model(spec = lasso_mod)

penalty_grid <- grid_regular(penalty(), levels = 20)

lasso_res <- lasso_wf |> 
  tune_grid(
    resamples = sub_folds,
    grid = penalty_grid,
    metrics = metric_set(rmse),
    control = control_grid(verbose = FALSE, save_pred = TRUE)
  )

lasso_res %>%
  collect_metrics()

best_lasso <- lasso_res %>%
  select_best(metric = "rmse")

```
The best RMSE of our lasso model is .0178, which indicates that the average difference between predicted and actual values in this model is about 1.7 percentage points. In the context of food insecurity, this is a relatively accurate model. As demonstrated in our exploratory data analysis, food insecurity across counties ranges from 5% to 25%. 

The LASSO regression results are promising- we will try similar feature engineering in a random forest model, to see how a nonparametric method may predict food insecurity levels.

#### Random Forest

In our random forest model, we again assign ID roles to identification variables, eliminate non-zero and near-zero variance predictors, normalize predictors, and group together infrequent values into an "other" category.
As for the hyperparameters, we increased the number of trees and mtrys which resulted in incremental improvements in our error metric.
```{r}

set.seed(2024)

rf_rec <- recipe(food_insecurity_chr ~ ., sub_training) %>%
  add_role(fips, new_role = "id") %>%
  step_rm(has_role("id")) %>%
  step_nzv(all_predictors()) %>%
  step_normalize(all_numeric_predictors()) %>%
  step_other(all_nominal(), threshold = 0.05)

rf_mod <- rand_forest(
  trees = 200,
  mtry = 30,
  min_n = 5
) %>%
  set_mode(mode = "regression") %>%
  set_engine(
    engine = "ranger", 
    importance = "impurity",
    num.threads = 4
  )

rf_wf <- workflow() %>%
  add_recipe(rf_rec) %>%
  add_model(rf_mod)

rf_res <- rf_wf %>%
  fit_resamples(resamples = sub_folds)

rf_res %>%
  collect_metrics() 

best_rf <- rf_res %>%
  select_best(metric = "rmse")

final_fit_rf <- finalize_workflow(rf_wf, best_rf) %>% 
  last_fit(split)


```
The results of our random forest model are slightly worse than our LASSO model, but the RMSE is generally still quite good. We see that on average there is a 1.8 percentage point difference between the predicted and true values in our food insecurity measure. Because the results of this model are similar to our LASSO regression, we can use it later to determine the importance of predictors in measuring food insecurity. 

#### Expand the Model Fit
We chose to apply our best lasso model to the testing data to see how it performs on unseen data. We can see that the RMSE of our LASSO model applied to the testing data is just slightly higher than the RMSE of the LASSO applied to the training data. This indicates that this model performs quite well on unseen data, which would be extremely useful for implementing on unseen county characteristics to predict future food insecurity.

```{r}

# We have selected the best LASSO model above, and assigned it to best_lasso

final_fit <- finalize_workflow(lasso_wf, best_lasso) %>% 
  last_fit(split)

final_fit %>%
  extract_fit_parsnip() %>%
  tidy()

final_fit %>%
  collect_metrics()

# Show Predictions

# Extract the workflow from final_fit
final_workflow <- extract_workflow(final_fit)

# Make predictions using the extracted workflow
final_predictions <- predict(final_workflow, new_data = testing)

final_predictions <- cbind(final_predictions, testing) %>%
  select(.pred, "food_insecurity_chr")

final_rmse <- sqrt(mean((final_predictions$food_insecurity_chr - final_predictions$.pred)^2))
print(final_rmse)


```

### Simulating Policy Changes

Lastly, we seek to understand how certain policy changes may affect food insecurity levels in counties. We developed a simple microsimulation model with a couple of the more "important" variables in our data to simulate how a change in these policies could increase or decrease food insecurity in counties. 

Using a variable importance plot from our random forest model, we can see which predictors in our model are the most useful for predicting rates of food insecurity in counties in our data set. Understanding the importance of predictors can help inform policies that influence food insecurity. For example, "PCT_WICWOMEN14" and "PCT_WICWOMEN16" represents the percentage of women participating in WIC in 2014 and 2016. Other important predictors are childhood poverty, rates of diabetes, and SNAP participation. Overall, it looks like county participation rates in state-level programs are relatively important predictors in our model.


```{r}
final_fit_rf |>
  extract_fit_parsnip() |>
  vip(num_features = 20) %>%
  .$data |>
  mutate(
    Importance = Importance / max(Importance),
    Variable = fct_reorder(.x = Importance, .f = Variable)
  ) |>
  ggplot(aes(Importance, Variable)) +
  geom_col() +
  theme_minimal()

```

For simplicity, we will apply a calculator to one of the most important predictors, participation of women in WIC, a food assistance program targeted toward new mothers and infants in need of supplemental nutrition assistance. The program provides staple foods to mothers and children who meet nutritional risk criteria. Modeling increased participation in the WIC program can give us an idea of how a change to this policy may affect food insecurity rates in counties in the United States. 

### Creating a Calculator to Change WIC Policy
The following function models a change in women participating in the WIC program. We targeted the simulation to change participation in WIC for counties with persistent childhood poverty, which is another important predictor of food insecurity identified by our random forest model.  


```{r}

#' WIC Participation Change
#'
#' @param child_pov # Variable representing persistent child poverty in counties, in this case "PERCHLDPOV10" 
#' @param wic_part # Original participation rate of women in WIC, in this case "PCT_WICWOMEN16"
#' @param wic_part_change # Change in participation to model. Can be any positive or negative integer. 
#'
#' @return
#' @export
#'
#' @examples
#' Example: Modeling a 10% increase in % of women participating in WIC
#' WIC_10 <- atlas_chr_snap %>%
 # mutate(PCT_WICWOMEN16 = 
       #  WIC_participation_change(
       #    child_pov = PERCHLDPOV10, 
       #      wic_part = PCT_WICWOMEN16, 
       #      wic_part_change = 20))

WIC_participation_change <- function(child_pov, wic_part, wic_part_change) {
  
  change <- dplyr::case_when(
    child_pov == 1 ~ wic_part + (wic_part_change),  # Increase by 20 for counties with persistent child poverty
    
    TRUE ~ wic_part  # Retain the original value for counties without persistent child poverty
  )
  return(change)
}

```

We then apply the function to model an increase in WIC participation and a decrease in WIC participation, and compare the changes in food insecurity as a result. To do this, we apply our calculator to our original dataset to change WIC participation rates, and then predict new food insecurity levels using our trained random forest model. This provides an approximation of how food insecurity levels may change if WIC participation increases or decreases.

The following tables show how food insecurity could change with this shift in WIC participation, across 10 population deciles of counties. 
### Modeling an Increase in WIC Participation
```{r}

WIC_10 <- atlas_chr_snap %>%
  mutate(PCT_WICWOMEN16 = 
           WIC_participation_change(
             child_pov = PERCHLDPOV10, 
             wic_part = PCT_WICWOMEN16, 
             wic_part_change = 20))  %>%
  select(-food_insecurity_chr)


# Extract the workflow from final_fit
rf_workflow <- extract_workflow(final_fit_rf)

# Predict food insecurity using the random forest model with the new WIC participation variable
predicted_food_insecurity <- predict(rf_workflow, new_data = WIC_10)

change_plus_10 <- cbind(predicted_food_insecurity, atlas_chr_snap$food_insecurity_chr, atlas_chr_snap) %>%
    rename("food_insecurity_original" = "atlas_chr_snap$food_insecurity_chr") 

change_plus_10 <- change_plus_10 %>%
  mutate(food_insecurity_change = .pred - food_insecurity_original)

change_plus_10$food_insecurity_change %>%
  summary()

change_plus_10$.pred %>%
  summary()

dist_table_increase <- change_plus_10 %>%
  mutate(pop_decile = ntile(Population_Estimate_2018, n = 10)) %>%
  group_by(pop_decile) %>%
  summarize(
    min_pop = min(Population_Estimate_2018),
    max_pop = max(Population_Estimate_2018),
    mean_food_insecurity = mean(.pred)
  )

dist_table_increase

```


### Modeling a Decrease in WIC Participation
```{r}

# Predicting food insecurity with a minus 10 percent WIC participation
WIC_minus_10 <- atlas_chr_snap %>%
  mutate(PCT_WICWOMEN16 = 
           WIC_participation_change(
             child_pov = PERCHLDPOV10, 
             wic_part = PCT_WICWOMEN16, 
             wic_part_change = -20
             ))  %>%
  select(-food_insecurity_chr)

food_insecurity_minus_10 <- predict(rf_workflow, new_data = WIC_minus_10)

change_minus_10 <- cbind(food_insecurity_minus_10, atlas_chr_snap$food_insecurity_chr, atlas_chr_snap) %>%
    rename("food_insecurity_original" = "atlas_chr_snap$food_insecurity_chr") 

change_minus_10 <- change_minus_10 %>%
  mutate(food_insecurity_change = .pred - food_insecurity_original)

change_minus_10$food_insecurity_change %>%
  summary()

change_minus_10$.pred %>%
  summary()


dist_table_decrease <- change_minus_10 %>%
  mutate(pop_decile = ntile(Population_Estimate_2018, n = 10)) %>%
  group_by(pop_decile) %>%
  summarize(
    min_pop = min(Population_Estimate_2018),
    max_pop = max(Population_Estimate_2018),
    mean_food_insecurity = mean(.pred)
  )
dist_table_decrease
```

### Modeling Original WIC Participation
```{r}

# Modeling original level of participation
dist_table_original <- change_minus_10 %>%
  mutate(pop_decile = ntile(Population_Estimate_2018, n = 10)) %>%
  group_by(pop_decile) %>%
  summarize(
    mean_food_insecurity = mean(food_insecurity_original),
    min_pop = min(Population_Estimate_2018),
    max_pop = max(Population_Estimate_2018))


dist_table_original


```

### Visualizing Distribution of Food Insecurity after WIC Participation Change
Lastly, we visualize this change in food insecurity with a line plot.
While the change is incremental, it is clear that WIC participation has a relationship with food insecurity levels in counties, and the strength of this relationship varies across population levels of counties. 

It appears that a decrease in WIC participation is associated with overall lower levels of food insecurity, across varying population levels. This makes sense if we consider the fact that increased WIC participation is likely correlated with higher levels of food insecurity. An increase in WIC participation is associated with a very slight increase in food insecurity, in the population deciles 6-8. The change is minimal in comparison to a decrease in WIC participation, however. 

The nature of the WIC program is evident in our line plot. The program is designed for mothers and infants who are in significant need of extra assistance for food, so it makes sense that the counties with higher food insecurity levels would have higher WIC participation rates. This simulation demonstrates the importance of the WIC program to counties with high levels of food insecurity, and can inform policy decisions around this and other food assistance programs. 

```{r}

# Combine the data frames
combined_data <- rbind(
  transform(dist_table_original, Condition = "Original"),
  transform(dist_table_increase, Condition = "Increase"),
  transform(dist_table_decrease, Condition = "Decrease")
)

# Plot
combined_plot <- ggplot(combined_data, aes(x = pop_decile, y = mean_food_insecurity, color = Condition)) +
  geom_line() +
  scale_x_continuous(breaks = 1:10) +
  labs(
    title = "Distribution of Food Insecurity by Population",
    subtitle = "Comparison of WIC Participation Conditions",
    x = "Population Decile",
    y = "Average Food Insecurity Levels"
  ) +
  theme_minimal()

# Display the plot
print(combined_plot)


```

#### Conclusion